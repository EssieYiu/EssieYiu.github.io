# python re模块

## 正则表达式

- `.`

  (点) 在默认模式，匹配除了换行的任意字符。如果指定了标签 [`DOTALL`](https://docs.python.org/zh-cn/3/library/re.html#re.DOTALL) ，它将匹配包括换行符的任意字符。

- `^`

  (插入符号) 匹配字符串的开头， 并且在 [`MULTILINE`](https://docs.python.org/zh-cn/3/library/re.html#re.MULTILINE) 模式也匹配换行后的首个符号。

- `$`

  匹配字符串尾或者换行符的前一个字符，在 [`MULTILINE`](https://docs.python.org/zh-cn/3/library/re.html#re.MULTILINE) 模式匹配换行符的前一个字符。 `foo` 匹配 `'foo'` 和 `'foobar'` , 但正则 `foo$` 只匹配 `'foo'`。更有趣的是， 在 `'foo1\nfoo2\n'` 搜索 `foo.$` ，通常匹配 `'foo2'` ，但在 [`MULTILINE`](https://docs.python.org/zh-cn/3/library/re.html#re.MULTILINE) 模式 ，可以匹配到 `'foo1'` ；在 `'foo\n'` 搜索 `$` 会找到两个空串：一个在换行前，一个在字符串最后。

- `*`

  对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串。 `ab*` 会匹配 `'a'`， `'ab'`， 或者 `'a'``后面跟随任意个 ``'b'`。

- `+`

  对它前面的正则式匹配1到任意次重复。 `ab+` 会匹配 `'a'` 后面跟随1个以上到任意个 `'b'`，它不会匹配 `'a'`。

- `?`

  对它前面的正则式匹配0到1次重复。 `ab?` 会匹配 `'a'` 或者 `'ab'`。

- `*?`, `+?`, `??`

  `'*'`, `'+'`，和 `'?'` 修饰符都是 *贪婪的*；它们在字符串进行尽可能多的匹配。有时候并不需要这种行为。如果正则式 `<.*>` 希望找到 `'<a> b <c>'`，它将会匹配整个字符串，而不仅是 `'<a>'`。在修饰符之后添加 `?` 将使样式以 *非贪婪`方式或者 :dfn:`最小* 方式进行匹配； 尽量 *少* 的字符将会被匹配。 使用正则式 `<.*?>` 将会仅仅匹配 `'<a>'`。

- `{m}`

  对其之前的正则式指定匹配 *m* 个重复；少于 *m* 的话就会导致匹配失败。比如， `a{6}` 将匹配6个 `'a'` , 但是不能是5个。

- `{m,n}`

  对正则式进行 *m* 到 *n* 次匹配，在 *m* 和 *n* 之间取尽量多。 比如，`a{3,5}` 将匹配 3 到 5个 `'a'`。忽略 *m* 意为指定下界为0，忽略 *n* 指定上界为无限次。 比如 `a{4,}b` 将匹配 `'aaaab'` 或者1000个 `'a'` 尾随一个 `'b'`，但不能匹配 `'aaab'`。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。

- `{m,n}?`

  前一个修饰符的非贪婪模式，只匹配尽量少的字符次数。比如，对于 `'aaaaaa'`， `a{3,5}` 匹配 5个 `'a'` ，而 `a{3,5}?` 只匹配3个 `'a'`。

- `\`

  转义特殊字符（允许你匹配 `'*'`, `'?'`, 或者此类其他），或者表示一个特殊序列；特殊序列之后进行讨论。如果你没有使用原始字符串（ `r'raw'` ）来表达样式，要牢记Python也使用反斜杠作为转义序列；如果转义序列不被Python的分析器识别，反斜杠和字符才能出现在字符串中。如果Python可以识别这个序列，那么反斜杠就应该重复两次。这将导致理解障碍，所以高度推荐，就算是最简单的表达式，也要使用原始字符串。

- `[]`

  用于表示一个字符集合。在一个集合中：字符可以单独列出，比如 `[amk]` 匹配 `'a'`， `'m'`， 或者 `'k'`。可以表示字符范围，通过用 `'-'` 将两个字符连起来。比如 `[a-z]` 将匹配任何小写ASCII字符， `[0-5][0-9]` 将匹配从 `00` 到 `59` 的两位数字， `[0-9A-Fa-f]` 将匹配任何十六进制数位。 如果 `-` 进行了转义 （比如 `[a\-z]`）或者它的位置在首位或者末尾（如 `[-a]` 或 `[a-]`），它就只表示普通字符 `'-'`。特殊字符在集合中，失去它的特殊含义。比如 `[(+*)]` 只会匹配这几个文法字符 `'('`, `'+'`, `'*'`, or `')'`。字符类如 `\w` 或者 `\S` (如下定义) 在集合内可以接受，它们可以匹配的字符由 [`ASCII`](https://docs.python.org/zh-cn/3/library/re.html#re.ASCII) 或者 [`LOCALE`](https://docs.python.org/zh-cn/3/library/re.html#re.LOCALE) 模式决定。不在集合范围内的字符可以通过 *取反* 来进行匹配。如果集合首字符是 `'^'` ，所有 *不* 在集合内的字符将会被匹配，比如 `[^5]` 将匹配所有字符，除了 `'5'`， `[^^]` 将匹配所有字符，除了 `'^'`. `^` 如果不在集合首位，就没有特殊含义。在集合内要匹配一个字符 `']'`，有两种方法，要么就在它之前加上反斜杠，要么就把它放到集合首位。比如， `[()[\]{}]` 和 `[]()[{}]` 都可以匹配括号。[Unicode Technical Standard #18](https://unicode.org/reports/tr18/) 里的嵌套集合和集合操作支持可能在未来添加。这将会改变语法，所以为了帮助这个改变，一个 [`FutureWarning`](https://docs.python.org/zh-cn/3/library/exceptions.html#FutureWarning) 将会在有多义的情况里被 `raise`，包含以下几种情况，集合由 `'['` 开始，或者包含下列字符序列 `'--'`, `'&&'`, `'~~'`, 和 `'||'`。为了避免警告，需要将它们用反斜杠转义。*在 3.7 版更改:* 如果一个字符串构建的语义在未来会改变的话，一个 [`FutureWarning`](https://docs.python.org/zh-cn/3/library/exceptions.html#FutureWarning) 会 `raise` 。

- `|`

  `A|B`， *A* 和 *B* 可以是任意正则表达式，创建一个正则表达式，匹配 *A* 或者 *B*. 任意个正则表达式可以用 `'|'` 连接。它也可以在组合（见下列）内使用。扫描目标字符串时， `'|'` 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 *A* 匹配成功， *B* 就不再进行匹配，即便它能产生一个更好的匹配。或者说，`'|'` 操作符绝不贪婪。 如果要匹配 `'|'` 字符，使用 `\|`， 或者把它包含在字符集里，比如 `[|]`.

- `(...)`

  （组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。匹配完成后，组合的内容可以被获取，并可以在之后用 `\number` 转义序列进行再次匹配，之后进行详细说明。要匹配字符 `'('` 或者 `')'`, 用 `\(` 或 `\)`, 或者把它们包含在字符集合里: `[(]`, `[)]`.

- `(?…)`

  这是个扩展标记法 （一个 `'?'` 跟随 `'('` 并无含义）。 `'?'` 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； `(?P<name>...)` 是唯一的例外。 以下是目前支持的扩展。

## 模块内容

re.compile(pattern, flags = 0)

将正则表达式的样式编译为一个正则表达式对象，可以用于匹配

re.search(pattern, string, flags = 0)

扫描整个字符串找到匹配样式的第一个位置，并返回一个相应的匹配对象。如果没有匹配，就返回none

re.match(pattern, string, flags = 0)

如果string开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的匹配对象。如果没有匹配，就返回none

re.fullmatch(pateern, string, flags = 0)

如果整个string匹配到正则表达式，就返回一个相应的匹配对象。否则返回一个none

re.split(pattern, string, maxsplit=0, flags=0)

用pattern分开string。如果在pattern中捕获到括号，那么所有的组里的文字也会包含着列表里。如果maxsplit非零，最多进行maxsplit次分割，剩下的字符全部返回到列表的最后一个元素

re.findall(pattern, string, flags= 0)

对string返回一个不重复的pattern的匹配列表，string从左到右进行扫描，匹配按照找到的顺序返回。如果样式里存在一到多个组，就返回一个组合列表；就是一个元组的列表（如果样式里有超过一个组合的话）。空匹配也会包含在结果里

例子

```python
#如果一个组匹配成功多次，就只返回最后一个匹配
m = re.match(r"(..)+","a1b2c3") #匹配3次
m.group(1) #仅返回最后一次匹配
‘c3’
```

